import pygame as pg
from grid import *
from a_star import a_star
from lpa_star import lpa_star
from d_star_lite import d_star_lite

'''The following are the available command keys for this pathfinding 
program.'''

# LEFT MOUSE CLICK
    # The first click places the start node.
    # The second click places the goal node.
    # Clicks after these nodes are placed will create barriers of the 
    # type determined by whatever type has been selected using the 
    # 'z' key toggle.
    # Note that algorithms cannot start until a start and end node 
    # have been selected.

# RIGHT MOUSE CLICK
    # Clears a node of any unique status (becomes an empty node).

# KEY 'z'
    # Toggle between vis (visible) and invis (invisible) barriers.

# KEY 'g'
    # This will generate a graph with barriers. 
    # The number of barriers corresponds to the set obstacle density 
    # of the program, which is by default 25%. 
    # Toggle the default obstacle density by changing the 
    # BARRIER_RAND_CONST in grid.py. 
    # In the program, you can toggle the type of barrier to be
    # generated by pressing the key 'z'. 
    # Pressing 'z' toggles between invis barrier generation and vis 
    # barrier generation.

# KEY 'm'
    # This will generate a graph with barriers like when pressing 
    # key 'g', except in this case a mixture of invis and vis barriers 
    # will be generated. 
    # When a node is selected to be a barrier during generation, there 
    # is a 50-50 chance of an invis or vis barrier being generated.

# KEY 'c'
    # Clear the grid (all nodes become empty nodes).

# KEY 's'
    # Clear the grid of all nodes that are paths, open, or closed. 
    # Node statuses are described in node.py.

# KEY 'b'
    # Restore the graph to its state before the last search algorithm 
    # was initiated.

# KEY '1'
    # Initiate A* without travel.

# KEY '2'
    # Initiate A* with travel.

# KEY '3'
    # Initiate LPA*.

# KEY '4'
    # Initiate D* Lite.


def handle_left_click(node, env):

    if not (env['start'] or env['end']):
        env['start'] = node
        node.make_start()

    elif not (env['end'] or node is env['start']):
        env['end'] = node
        node.make_end()

    elif not (env['start'] or node is env['end']):
        env['start'] = node
        node.make_start()

    elif not (node is env['end'] or node is env['start']):
        
        if env['barriers_are_vis']:
            node.make_vis_barrier()
        
        else:
            node.make_invis_barrier()


def handle_right_click(node, env):
    node.reset()
    
    if node is env['start']:
        env['start'] = None
    
    elif node is env['end']:
        env['end'] = None


def handle_search_keys(event, env):
    
    for row in env['grid']:
        for node in row:
            node.update_neighbors(env['grid']) 
    
    env['start'].make_start()
    env['end'].make_end()

    # do A* without traversal to goal
    if event.key == pg.K_1:
        grid, start, end = duplicate_grid(env['grid'])
        env['prior_grid'] = grid
        env['prior_start'] = start
        env['prior_end'] = end
        env['invis_barriers'] = [
            node for row in env['grid'] for node in row 
            if node.is_invis_barrier()
        ]
        
        a_star(lambda: draw(env['grid']), env, False)

    # do A* with traversal to goal
    elif event.key == pg.K_2:
        grid, start, end = duplicate_grid(env['grid'])
        env['prior_grid'] = grid
        env['prior_start'] = start
        env['prior_end'] = end
        env['invis_barriers'] = [
            node for row in env['grid'] for node in row 
            if node.is_invis_barrier()
        ]

        a_star(lambda: draw(env['grid']), env, True)

    # do LPA*
    elif event.key == pg.K_3:
        grid, start, end = duplicate_grid(env['grid'])
        env['prior_grid'] = grid
        env['prior_start'] = start
        env['prior_end'] = end
        env['invis_barriers'] = [
            node for row in env['grid'] for node in row 
            if node.is_invis_barrier()
        ]

        lpa_star(lambda: draw(env['grid']), env)

    # do D* Lite
    elif event.key == pg.K_4:
        grid, start, end = duplicate_grid(env['grid'])
        env['prior_grid'] = grid
        env['prior_start'] = start
        env['prior_end'] = end
        
        d_star_lite(lambda: draw(env['grid']), env)


def handle_prep_keys(event, env):
    # clear grid
    if event.key == pg.K_c:
        env['start'] = None
        env['end'] = None
        env['grid'] = make_grid()

        # "safe clear" grid - remove everything except barriers, 
        # start, and end
    elif event.key == pg.K_s:
        l = lambda n: n.is_open() or n.is_closed() or n.is_path()
        reset_nodes(env['grid'], l)

    # toggle barrier type (vis or invis)
    elif event.key == pg.K_z:
        env['barriers_are_vis'] = not env['barriers_are_vis']

    # generate barriers
    elif event.key == pg.K_g:
        env['start'] = None
        env['end'] = None
        env['grid'] = make_grid()
        generate_barriers(env['grid'], env['barriers_are_vis'])

    # generate a mix of invis and vis barriers
    elif event.key == pg.K_m:
        env['start'] = None
        env['end'] = None
        env['grid'] = make_grid()
        generate_barriers_mixed(env['grid'])

    # restore grid to original version preceding latest algorithm 
    # visualization
    elif event.key == pg.K_b and env['prior_grid']:
        env['grid'] = env['prior_grid']
        env['start'] = env['prior_start']
        env['end'] = env['prior_end']


def handle_interaction(event, env):
    pos = pg.mouse.get_pos()
    row, col = get_clicked_pos(pos)
    node = env['grid'][row][col]

    if pg.mouse.get_pressed()[0]: # left click
        handle_left_click(node, env)
    
    elif pg.mouse.get_pressed()[2]:  # Right click
        handle_right_click(node, env)

    if event.type == pg.KEYDOWN:
        
        if env['start'] and env['end']:
            handle_search_keys(event, env)

        handle_prep_keys(event, env)


def main():
    run = True
    env = {
        'grid': make_grid(),
        'start': None,
        'end': None,
        'prior_grid': None,
        'prior_start': None,
        'prior_end': None,
        'barriers_are_vis': True,
        'invis_barriers': []
    }

    while run:
        draw(env['grid'])

        for event in pg.event.get():

            if event.type == pg.QUIT:
                run = False

            handle_interaction(event, env)

    pg.quit()


if __name__ == '__main__':
    main()

